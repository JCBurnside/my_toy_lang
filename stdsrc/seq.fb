trait IntoSequence =
    type Item
    type IntoSeq : Sequence<Item>;
    let into_seq : self -> IntoSeq;

for<T> trait Sequence =
    let next : &mut Self -> Option<T>

for<T,S:Sequence<T>, U> public type Map = {
    base : S,
    fun : T->U,
}

public let to_list (mut s) = 
    match s.next
    | Some t -> [t] ++ to_list s
    | None -> [||]



for<T,S:Sequence<T>, U> implement Sequence<U> for Map<T,S,U> =
    let next &mut self = 
        self.base.next |> Option::map self.fun 

public let map func s = Map { base:s, func }

for<TLeft,TRTLeft,TRight,TRTRight,S:Sequence<(TLeft,TRight>)>>
public let bimap funcleft funcright s : (TLeft->TRTLeft)->(TRight->TRTRight) -> S -> Map<(TLeft,TRight),S,(TRTLeft,TRTRight)> =
    Map {
        base: s,
        fun : ((left,right) -> (funcleft left,funcright right))
    }


public let foldl left func (mut s) =
    match s.next 
    | Some t -> foldl (func left t) s
    | None -> left
/*

[a,b,c]
|> seq::foldl 1 (+) 

(((1+a)+b)+c)

*/

public let foldr right func (mut s) =
    match s.next
    | Some t -> func (foldr func s) right
    | None -> right 

public let foldl1 func (mut s) =
    match s.next 
    | Some t -> foldl t func s
    | None -> error "there must be at least one element"


public for<T:IntoSeq> let foldr1 func (s:T) = foldr1_impl func (s.into_seq) 

let foldr1_impl func (mut s) =
    match s.next
    | Some t -> foldr t func s
    | None -> error "there must be at least one element"


for<T,Inner:Sequence<T>, Outer:Sequence<Inner>> 
public type Flatten {
    curr : Option<Inner>,
    seq : Outer,
}
for<T,Inner:Sequence<T>, Outer:Sequence<Inner>>
public let flatten s = Flatten {
    curr : None,
    seq : s,
}
for<T,Inner:Sequence<T>, Outer:Sequence<Inner>>
implement Sequence<T> for Flatten =
    let next self =
        match self.curr |> Option::map seq::next
        | Some ele -> Some ele
        | None -> match self.seq.next 
            | None -> None
            | Some i -> 
                self.curr = Some i;
                self.next

for<T> trait FromSeq<T> =
    for<S:Sequence<T>> let from_seq s : S -> Self;


for<T,Coll:FromSeq<T>, S:Sequence<T>>
let collect = Coll::from_seq
