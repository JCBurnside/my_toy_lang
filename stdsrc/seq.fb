
//TODO may have to wait until I can get traits working
// or even generate from the compiler as I don't see how I can make this lazy yet.
// for<T,U,S:Seq<T>> let map func s : (T -> U) -> S -> Map<S,U> =
// could probably using custom types.

trait Seq =
    type Item;
    let next : &mut Self -> Option<Item>;
    for<Coll:FromSeq<Item>> let collect = Coll::from_seq;

for<S:Seq, U> 
public type Map = {
    base : S,
    fun : S::Item->U,
}

for<T,S> public let sum (seq:S) 
where S : Seq<Item = T>, T : Add<T, Result=T> = foldl1 (+) seq

for<T,S> public let prod (seq:S)
where S : Seq<Item = T>, T : Mul<T, Result=T> = foldl1 (*) seq

for<T,S:Seq<Item = T>> public let to_list (mut s:S) = 
    match s.next
    | Some t -> [|t|] ++ to_list s
    | None -> [||]

for<T,S:Seq<Item = T>> public let to_vec (s:S) = s |> seq::collect::<Vec<T>>

for<T,S:Seq<Item = T>, U> implements Seq<U> for Map<S,U> =
    let next &mut self = 
        self.base.next |> Option::map self.fun 

for<T,S:Seq<Item=T>,U> public let map (func:T->U) (s:S) = Map { base:s, func }

for<TLeft,TRTLeft,TRight,TRTRight,S:Seq<(TLeft,TRight>)>>
public let bimap funcleft funcright s : (TLeft->TRTLeft)->(TRight->TRTRight) -> S -> Map<(TLeft,TRight),S,(TRTLeft,TRTRight)> =
    Map {
        base: s,
        fun : ((left,right) -> (funcleft left,funcright right))
    }

public let foldl left func (mut s) =
    match s.next 
    | Some t -> foldl (func left t) s
    | None -> left
/*
[a,b,c]
|> seq::foldl 1 (+) 

(((1+a)+b)+c)
*/

public let foldr right func (mut s) =
    match s.next
    | Some t -> func (foldr func s) right
    | None -> right 

public let foldl1 func (mut s) =
    match s.next 
    | Some t -> foldl t func s
    | None -> error "there must be at least one element"

public let foldr1 func (mut s) =
    match s.next
    | Some t -> foldr t func s
    | None -> error "there must be at least one element"

for<T,Inner:Seq<T>, Outer:Seq<Inner>> 
public type Flatten {
    curr : Option<Inner>,
    seq : Outer,
}

for<T,Inner:Seq<T>, Outer:Seq<Inner>>
public let flatten s = Flatten {
    curr : None,
    seq : s,
}

for<T,Inner:Seq<T>, Outer:Seq<Inner>>
implements Seq<T> for Flatten =
    let next self =
        match self.curr |> Option::map seq::next
        | Some ele -> Some ele
        | None -> match self.seq.next 
            | None -> None
            | Some i -> 
                self.curr = Some i;
                self.next

for<T> trait FromSeq<T> =
    for<S:Seq<T>> let from_seq s : S -> Self;
