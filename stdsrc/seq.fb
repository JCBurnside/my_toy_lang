
//TODO may have to wait until I can get traits working
// or even generate from the compiler as I don't see how I can make this lazy yet.
// for<T,U,S:Seq<T>> let map func s : (T -> U) -> S -> Map<S,U> =
// could probably using custom types.

for<T> trait Seq =
    let next : &mut Self -> Option<T>

for<T,S:Seq<T>, U> public type Map = {
    base : S,
    fun : T->U,
}

public let to_list (mut s) = 
    match s.next
    | Some t -> [t] ++ to_list s
    | None -> [||]



for<T,S:Seq<T>, U> implement Seq<U> for Map<T,S,U> =
    let next &mut self = 
        self.base.next |> Option::map self.fun 

public let map func s = Map { base:s, func }

for<TLeft,TRTLeft,TRight,TRTRight,S:Seq<(TLeft,TRight>)>>
public let bimap funcleft funcright s : (TLeft->TRTLeft)->(TRight->TRTRight) -> S -> Map<(TLeft,TRight),S,(TRTLeft,TRTRight)> =
    Map {
        base: s,
        fun : ((left,right) -> (funcleft left,funcright right))
    }


public let foldl left func (mut s) =
    match s.next 
    | Some t -> foldl (func left t) s
    | None -> left
/*

[a,b,c]
|> seq::foldl 1 (+) 

(((1+a)+b)+c)

*/

public let foldr right func (mut s) =
    match s.next
    | Some t -> func (foldr func s) right
    | None -> right 

public let foldl1 func (mut s) =
    match s.next 
    | Some t -> foldl t func s
    | None -> error "there must be at least one element"

public let foldr1 func (mut s) =
    match s.next
    | Some t -> foldr t func s
    | None -> error "there must be at least one element"


for<T,Inner:Seq<T>, Outer:Seq<Inner>> 
public type Flatten {
    curr : Option<Inner>,
    seq : Outer,
}
for<T,Inner:Seq<T>, Outer:Seq<Inner>>
public let flatten s = Flatten {
    curr : None,
    seq : s,
}
for<T,Inner:Seq<T>, Outer:Seq<Inner>>
implement Seq<T> for Flatten =
    let next self =
        match self.curr |> Option::map seq::next
        | Some ele -> Some ele
        | None -> match self.seq.next 
            | None -> None
            | Some i -> 
                self.curr = Some i;
                self.next

for<T> trait FromSeq<T> =
    for<S:Seq<T>> let from_seq s : S -> Self;


for<T,Coll:FromSeq<T>, S:Seq<T>>
let collect = Coll::from_seq
