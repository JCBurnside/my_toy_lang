mod option

for<T> enum Option =
    | Some T
    | None

for<T> implements Option<T> where
    for<U> let map &self func : &Option<T> -> (&T -> U) -> Option<U> =
        match self ->
        | Option::Some t -> func t |> Option::Some
        | Option::None -> Option::None
    let unwrap self : Option<T> -> T =
        match self
        | Option::Some t -> t
        | Option::None -> error 
    let unwrap_or self v : Option<T> -> T -> T
        match self
        | Option::Some t -> t
        | Option::None -> v
    let unwrap_or_else self fun : Option<T> -> (()->T) -> T =
        match self
        | Option::Some t -> t
        | Option::None -> fun
    let is_some &self : &Option<T> -> bool =
        match self
        | Option::Some _ -> true
        | Option::None -> false
    let is_none &self : &Option<T> -> bool = !self.is_some
    for<E> let ok_or self err : Option<T> -> E -> Result<T,E> = 
        match self
        | Option::Some t -> Result::Ok t
        | Option::None -> Result::Err err
    for<E> let ok_or_else self err_fun : Option<T> -> (()->E) -> Result<T,E> =
        match self
        | Option::Some t -> Result::Ok t
        | Option::None -> err_fun |> Result::Err

    for<'opt> let as_ref &self : &'opt Option<T> -> Option<&'opt T>
        match self
        | Option::Some t -> Option::Some &t
        | Option::None -> Option::None

    for<'opt> let as_mut (&mut self) : &'opt mut Option<T> -> Option<&'opt mut T>
        match self
        | Option::Some t -> Option::Some &mut t
        | Option::None -> Option::None
