mod result
for<T,E> enum Result =
| Ok T
| Err E
// TODO: needs 
// for<T,E> let Ok = Result::Ok

// for<T,E> let Err = Result::Err

for<T,U,E> let map func r : (T -> U) -> Result<T,E> -> Result<U,E> =
    match r ->
    | Result::Ok t -> func t |> Result::Ok
    | Result::Err e -> Result::Err e

for<T,EOld, ENew> let map_err func r : (EOld -> ENew) -> Result<T,EOld> -> Result<T,ENew> =
    match r ->
    | Result::Ok t -> Result::Ok t
    | Result::Err e -> func e |> Result::Err e

for<T,E> let ok r : Result<T,E> -> Option<T> =
    match r ->
    | Result::Ok t -> Option::Some t
    | Result::Err _ -> Option::None

